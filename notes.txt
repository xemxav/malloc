Il faut garder en 'memoire' la liste des zones libres ?
Creer un processus fils qui va garder en memoire un liste chainé avec les adresses libres et la taille de la zone dans une liste chainée ?

Organiser les allocations dans une page en fonction de leur taille ? genre par block qui de taille n tel que page/n = nb de block

Une Variable global pour enregistrer les pages ?

Qu'est ce qu'une librairie dynamique, un .so ?
on peut verifier les fonctions contenues dans un .so avec nm

il faut set le path de la libraire avec des variables d'environnement pour charger la lib
	setenv DYLD_LIBRARY_PATH . ->permet de lui dire ou trouver les librairie
	setenv DYLD_INSERT_LIBRARIES nom_de_la_lib.so ->permet de lui dire quelle lib a injecter

	ensuite il faut demander au loader de fonctionner differement, il faut
		setenv DYLD_FORCE_FLAT_NAMESPACE 1

Regarder video Malloc

regle de makefile
	compilé en librairie partagé gcc -shared -o $(NAME).so

utilisation de mmap:

void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);

	*addr = il faut mettre 0 si il n'existe pas, quid d'un pointeur null ?
	len : combien de byte

	prot : il faut chosir les prots pour donner les autorisations

	flag : on prend MAP_ANON car on ne veut pas mapper de fichier
			on prend MAP_PRIVATE car en cas d'un fork pour dubliquer la zone memoire
	fd : -1 car on a pas de fichier
	offset : 0, caar pas de offset

    mmap(NULL ou 0, getpagedir(), ROT_READ|PROT_WRITE, MAP_ANON|MAP_SHARED, -1, 0);

    stocker les adresses rendu dans une structure, connaitre la taille et l'adresse de debut.
    La fonction doit decider quelle adresse doit la zone déjà alloue elle renvoie ou si elle a besoin de reallouer une zone

    se renseigner sur les algo de "rangement " ?

    TROUVER UN MOYEN DE TOUT FREE SI LE PROGRAMME s'ARRETTE


    RLIMIT_AS
    Taille maximum de la mémoire virtuelle du processus en octets.
    Cette limite affecte les appels à brk(2), mmap(2) et mremap(2), qui échouent
    avec l'erreur ENOMEM en cas de dépassement de cette limite. De même,
    l'extension de la pile automatique échouera (et générera un SIGSEGV qui tuera
    le processus si aucune pile alternative n'a été définie par un appel
    à sigaltstack(2)). Depuis que cette valeur est de type long, sur les machines
    où le type long est sur 32 bits, soit cette limite est au plus 2 GiB,
    soit cette ressource est illimitée.